class Solution {
    public int[][] generateMatrix(int n) {
        int[][] matrix= new int[n][n];
        int colbeg=0;
        int colend=n-1;
        int rowbeg=0;
        int rowend=n-1;
        int count=1;

        while(rowbeg <= rowend && colbeg <= colend){
      //travel right
      for(int j=colbeg;j<=colend;j++){
        matrix[rowbeg][j]=count;
        count++;
      }
      rowbeg++;
      //travel down
      for(int i=rowbeg;i<=rowend;i++){
        matrix[i][colend]=count;
        count++;
      }
      colend--;

      // travel left in row 
      if(rowbeg<=rowend){
for(int j=colend;j>=colbeg;j--){
        matrix[rowend][j]=count;
        count++;
      }
      rowend--;
      }
        

      //travel up 
      if(colbeg<=colend){
    for(int i=rowend;i>=rowbeg;i--){
        matrix[i][colbeg]=count;
        count++;
      }
      colbeg++;
      }
        }
        return matrix;
    }
}

Time Complexity:
- The algorithm traverses each element of the matrix exactly once.
- Each element is assigned a value during one of the four directional traversals (right, down, left, up).
- Since there are n^2 elements, the total number of operations is proportional to n^2.
- Therefore, the time complexity is O(n^2).

Space Complexity:
- The algorithm uses an additional 2D array of size n x n to store the result.
- Apart from the output matrix, only a few integer variables are used for indices and counters.
- Hence, the auxiliary space complexity is O(n^2) due to the output matrix.
- If considering only auxiliary space (excluding output), it is O(1).

In summary:
Time complexity: O(n^2)
Space complexity: O(n^2) (due to the output matrix)
