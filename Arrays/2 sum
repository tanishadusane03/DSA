
       class Solution {
    public int[] twoSum(int[] nums, int target) {
        int n=nums.length;
        Map<Integer,Integer> map=new HashMap<>();
        int[] result=new int[2];
        for(int i=0;i<n;i++){
            if(map.containsKey(target-nums[i])){
                result[1]=i;
                result[0]=map.get(target-nums[i]);
                return result;
            }
            map.put(nums[i],i);
        }
        return result;
    }
}
Time complexity: O(n)
Space complexity: O(n)

2ND approach
public class Main {
    public static String twoSum(int n, int []arr, int target) {
        Arrays.sort(arr);
        int left = 0, right = n - 1;
        while (left < right) {
            int sum = arr[left] + arr[right];
            if (sum == target) {
                return "YES";
            } else if (sum < target) left++;
            else right--;
        }
        return "NO";
    }
The time complexity of the given twoSum method is dominated by the sorting step. Sorting the array takes O(n log n) time, where n is the size of the array. The two-pointer traversal after sorting runs in linear time, O(n), since each element is visited at most once. Therefore, the overall time complexity is O(n log n).

The space complexity is O(1) because the algorithm sorts the array in place and uses only a fixed amount of additional variables (left, right, sum), regardless of the input size. No extra data structures proportional to n are used, so the space complexity is constant.
