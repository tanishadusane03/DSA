Approach : Take one pointer and fix it and then use the 2 sum technique to find the corresponding pairs
SORT THE ARRAY FIRTS
class Solution {
    public List<List<Integer>> threeSum(int[] a) {
        int n=a.length;
        Arrays.sort(a);
            Set<List<Integer>> result= new HashSet<>();
        for(int i=0;i<n-2;i++){
           int l=i+1;
           int r=n-1;    
         
         while(l<r){
            int sum = a[i]+a[l]+a[r];

            if(sum==0){
              result.add(Arrays.asList(a[i],a[l],a[r]));
              l++;
              r--;
            }
            else if(sum>0){
                r--;
                }
                else{
                    l++;
                }
         }


        }
        return new ArrayList<>(result);
    }
}
The provided code implements the 3Sum problem solution using sorting and a two-pointer approach with a HashSet to avoid duplicates.

Time Complexity:
- Sorting the array takes O(n log n), where n is the length of the input array.
- The outer loop runs approximately n times.
- For each iteration of the outer loop, the inner while loop runs with two pointers, which in the worst case traverses the remaining array once, resulting in O(n) per iteration.
- Therefore, the total time complexity is O(n log n) for sorting plus O(n^2) for the nested loops, resulting in overall O(n^2).

Space Complexity:
- The space used for sorting is O(1) if the sorting is in-place.
- The HashSet `result` stores unique triplets; in the worst case, there could be O(n^2) triplets (though typically fewer).
- The space for the output list is proportional to the number of unique triplets, which can be up to O(n^2) in the worst case.
- Additional variables and data structures (like the temporary list for triplets) use O(1) space.
- Overall, the space complexity is O(n^2) in the worst case due to the storage of result triplets.

In summary:
- Time complexity: O(n^2)
- Space complexity: O(n^2)



class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int n=nums.length;
        Arrays.sort(nums);
        List<List<Integer>> list=new ArrayList<>();
        for(int i=0;i<n;i++){
            if(i>0 && nums[i]==nums[i-1]){
                continue;
            }
            int j=i+1;
            int k=n-1;
            while(j<k && k<n){
                int sum=nums[i]+nums[j]+nums[k];
                if(sum>0){
                    k--;
                }
                else if(sum<0){
                    j++;
                }
                else{
                    List<Integer> temp=new ArrayList<>();
                    temp.add(nums[i]);
                    temp.add(nums[j]);
                    temp.add(nums[k]);
                    list.add(temp);
                    j++;
                    while(nums[j]==nums[j-1] && j<k){
                        j++;
                    }

                }
            }
        }
        return list;
    }
}
TC : O(N^2)
SC: O(1)
