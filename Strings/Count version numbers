class Solution {
    public int compareVersion(String version1, String version2) {
        int p1 = 0, p2 = 0;
        int n = version1.length();
        int m = version2.length();

        while (p1 < n || p2 < m) {
            // find end of current segment in version1
            int i1 = p1;
            while (i1 < n && version1.charAt(i1) != '.') {
                i1++;
            }

            // find end of current segment in version2
            int i2 = p2;
            while (i2 < m && version2.charAt(i2) != '.') {
                i2++;
            }

            // extract substrings (or "0" if none)
            String sub1, sub2;

            if (p1 < n) {
                sub1 = version1.substring(p1, i1);
            } else {
                sub1 = "0";
            }

            if (p2 < m) {
                sub2 = version2.substring(p2, i2);
            } else {
                sub2 = "0";
            }

            // convert to integers
            int n1 = Integer.parseInt(sub1);
            int n2 = Integer.parseInt(sub2);

            // compare
            if (n1 > n2) return 1;
            if (n1 < n2) return -1;

            // move past dot
            p1 = i1 + 1;
            p2 = i2 + 1;
        }

        return 0;
    }
}

The time complexity of this solution is O(max(N, M)), where N is the length of version1 and M is the length of version2. This is because the algorithm processes each character of both version strings at most once, extracting and comparing each segment sequentially.

The space complexity is O(1), aside from the input strings. The algorithm uses a fixed amount of extra space for variables such as pointers and temporary strings for segments, which do not grow with input size. The substring operations create new strings, but since these are temporary and their total length across the entire process sums up to the length of the input strings, the overall auxiliary space remains constant.
